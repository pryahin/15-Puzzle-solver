# Решатель пятнашек 

* [Задача](#task)
* [Подходы к решению задачи](#solutions)
  * [Алгоритм А*](#astar)
  * [Алгоритм IDА*](#idastar)
  * [Поиск в ширину](#bfs)
* [Формат данных](#dataformat)
  * [Входные данные](#inputdata)
  * [Выходные данные](#outputdata)
* [Текущая версия](#currentversion)
  * [Установка](#install)
  * [Запуск](#launch)
  * [Генерация случайного поля](#gentest)
* [План развития](#roadmap)
<hr>


<a name="task"></a>
## Задача
> Постройте программу для решения головоломки «Пятнашки» произвольного размера.

<a name="solutions"></a>
## Подходы к решению задачи
В качестве алгоритма поиска может использоваться алгоритм A*, IDA*, поиск в ширину.

<a name="astar"></a>
### Алгоритм А*
Поиск A* — в информатике и математике, алгоритм поиска по первому наилучшему совпадению на графе, который находит маршрут с наименьшей стоимостью от одной вершины (начальной) к другой (целевой, конечной).

Порядок обхода вершин определяется эвристической функцией «расстояние + стоимость» (обычно обозначаемой как f(x)). Эта функция — сумма двух других: функции стоимости достижения рассматриваемой вершины (x) из начальной (обычно обозначается как g(x) и может быть как эвристической, так и нет), и функции эвристической оценки расстояния от рассматриваемой вершины к конечной (обозначается как h(x)).

Функция h(x) должна быть допустимой эвристической оценкой, то есть не должна переоценивать расстояния к целевой вершине. Например, для задачи маршрутизации h(x) может представлять собой расстояние до цели по прямой линии, так как это физически наименьшее возможное расстояние между двумя точками.

Этот алгоритм был впервые описан в 1968 году. Это по сути было расширение алгоритма Дейкстры, созданного в 1959 году. Новый алгоритм достигал более высокой производительности (по времени) с помощью эвристики. В их работе он упоминается как «алгоритм A». Но так как он вычисляет лучший маршрут для заданной эвристики, он был назван A*.

A* пошагово просматривает все пути, ведущие от начальной вершины в конечную, пока не найдёт минимальный. Как и все информированные алгоритмы поиска, он просматривает сначала те маршруты, которые «кажутся» ведущими к цели. От жадного алгоритма, который тоже является алгоритмом поиска по первому лучшему совпадению, его отличает то, что при выборе вершины он учитывает, помимо прочего, весь пройденный до неё путь. Составляющая g(x) — это стоимость пути от начальной вершины, а не от предыдущей, как в жадном алгоритме.

В начале работы просматриваются узлы, смежные с начальным; выбирается тот из них, который имеет минимальное значение f(x), после чего этот узел раскрывается. На каждом этапе алгоритм оперирует с множеством путей из начальной точки до всех ещё не раскрытых (листовых) вершин графа — множеством частных решений, — которое размещается в очереди с приоритетом. Приоритет пути определяется по значению f(x) = g(x) + h(x). Алгоритм продолжает свою работу до тех пор, пока значение f(x) целевой вершины не окажется меньшим, чем любое значение в очереди, либо пока всё дерево не будет просмотрено. Из множества решений выбирается решение с наименьшей стоимостью.

**Пример работы алгоритма:**

![astar](https://upload.wikimedia.org/wikipedia/commons/5/5d/Astar_progress_animation.gif)

<a name="idastar"></a>
### Алгоритм IDА*
**I**terative **D**eepening **A*** (Алгоритм A* с итеративным углублением) — применение идеи итеративного углубления в контексте эвристического поиска.

Неинформированный алгоритм итеративного углубления останавливает развёртывание, когда глубина поиска d превышает текущий предел глубины l. Информированный алгоритм IDA* останавливает развёртывание, когда оценка f(n) стоимости пути через текущий узел n превышает текущий предел стоимости пути bound.

Алгоритм IDA* отличается минимальными затратами памяти по сравнению с A* и сравнительно малым (в случае удачного выбора эвристики) количеством развёрнутых узлов по сравнению с IDDFS.

<a name="bfs"></a>
### Поиск в ширину
Поиск в ширину работает путём последовательного просмотра отдельных уровней графа, начиная с узла-источника `u`

Рассмотрим все рёбра `(u,v)`, выходящие из узла `u`. Если очередной узел `v` является целевым узлом, то поиск завершается; в противном случае узел v добавляется в очередь. После того, как будут проверены все рёбра, выходящие из узла `u`, из очереди извлекается следующий узел `u`, и процесс повторяется.

**Пример работы алгоритма:**

![bfs](http://nio01.altervista.org/blog/wp-content/uploads/2015/04/dfs.gif)

<a name="dataformat"></a>
## Формат входных/выходных данных
<a name="inputdata"></a>
### Входные данные
Входные данные подаются в виде матрицы в формате json
```json
[
  [1,2,3,4],
  [5,6,7,8],
  [9,10,0,12],
  [13,14,11,15]
]
```
<a name="outputdata"></a>
### Выходные данные
Ошибка при неверном формате данных/невозможности решения данной пятнашки
```json
{ 
  "message": "Некорректный формат входных данных"
}
```
Или порядок ходов при найденом решении
```
  1  2  3  4
  5  6  7  8
  9 10  0 12
 13 14 11 15

  1  2  3  4
  5  6  7  8
  9 10 11 12
 13 14  0 15

  1  2  3  4
  5  6  7  8
  9 10 11 12
 13 14 15  0
```

<a name="currentversion"></a>
## Текущая версия
Текущая версия программы находится в ветке `develop`
Для того, чтобы перейти в ветку девелоп 

<a name="install"></a>
### Установка

```
npm install
```


<a name="launch"></a>
### Запуск

```
npm start
```

<a name="gentest"></a>
### Генерация поля и поиск решения для него:
```
npm run test N M
```

N - Задает поле NxN. По умолчанию = 4.
M - Генерируется решенное поле, и делается M смещений. По умолчанию = 20.

<a name="roadmap"></a>
## План действий

> На данный момент реализован алгоритм А*.
>
> У нас есть поле и мы смотрим какие поля могут получиться из текущего.
>
> g(x) = Кол-во ходов сделанных из начального до текущего
>
> h(x) = Суммарный путь, который нужной пройти каждой цифре ходов для того, чтобы она оказалась на своем месте

Планируется далее:
1. Поиск других более удачных h(x)
2. Совершенствование алгоритма
3. Написание тестов
4. Доказательства NP-трудности, сложности и т.п.
